import sys
import matplotlib.pyplot as plt

log = sys.argv[1]
task_info = {}
worker_info = {}
library_info = {}
origin = 'manager_start'
manager_start = 0
manager_end = 0
first_task_start = float('inf')

lines = open(log, 'r').read().splitlines()

# parse relevant info
for line in lines:
    (time, m_pid, category, obj, status, info) = line.split(maxsplit=5)
    try:
        time = float(time)/1000000
    except:
        pass
    if category == 'TASK':
        if obj not in task_info:
            task_info[obj] = {}
        if status == 'RUNNING':
            task_info[obj]['start_time'] = float(time)
            if time < first_task_start:
                first_task_start = time
            task_info[obj]['worker'] = info.split()[0]
        if status == 'WAITING_RETRIEVAL':
            task_info[obj]['stop_time'] = float(time)
        if status == 'READY':
            function = info.split()[0]
            task_info[obj]['function'] = function
        
    if category == 'WORKER':
        if obj not in worker_info:
            worker_info[obj] = {'tasks':[], 'libraries':[]}
        if status == 'CONNECTION':
            worker_info[obj]['start_time'] = float(time)
        if status == 'DISCONNECTION':
            worker_info[obj]['stop_time'] = float(time)

    if category == 'LIBRARY':
        if obj not in library_info:
            library_info[obj] = {}
        if status == 'STARTED':
            library_info[obj]['start_time'] = float(time)
            library_info[obj]['worker'] = info

    if category == 'MANAGER':
        if status == 'START':
            manager_start = float(time)
        if status == 'END':
            manager_end = float(time)


# match tasks to workers
# print(worker_info)
for task in task_info:
    if task_info[task]['worker'] in worker_info and 'stop_time' in task_info[task]:
        worker_info[task_info[task]['worker']]['tasks'].append(task_info[task])
for library in library_info:
    try:
        if library_info[library]['worker'] in worker_info:
            worker_info[library_info[library]['worker']]['libraries'].append(library_info[library])
    except:
        pass

g_ys = []
g_widths = []
g_lefts = []
m_ys = []
m_widths = []
m_lefts = []
l_ys = []
l_widths = []
l_lefts = []
count = 0
total_tasks = 0
total_assigned = 0
print(len(worker_info))
for worker in worker_info:
    slots = {}
    tasks = [[task['start_time'],task['stop_time'],task['function']] for task in worker_info[worker]['tasks']]
    tasks = sorted(tasks, key=lambda x: x[0])
    print('number of tasks:', len(tasks))
    total_tasks += len(tasks)
    for task in tasks:
        if not slots:
            slots[1] = [task]
        else:
            fits = 0
            for slot in slots:
                if task[0] > slots[slot][-1][1]:
                    slots[slot].append(task)
                    fits += 1
                    break
            if not fits:
                slots[len(slots) + 1] = [task]

    print('number of slots:', len(slots))
    for slot in slots:
        total_assigned += len(slots[slot])
    for slot in slots:
        count += 1
        for task in slots[slot]:
            if 'random' in task[2]:
                g_ys.append(count)
                g_widths.append(task[1] - task[0])
                g_lefts.append(task[0] - first_task_start)
            else:
                m_ys.append(count)
                m_widths.append(task[1] - task[0])
                m_lefts.append(task[0] - first_task_start)

    for library in worker_info[worker]['libraries']:
        count += 1
        l_ys.append(count)
        l_widths.append(manager_end - library['start_time'])
        l_lefts.append(library['start_time'] - first_task_start)


print('assigned:', total_assigned)
print('total_tasks', total_tasks)
#plt.barh(g_ys, g_widths, left=g_lefts, label='Generate Matrix', color='blue')
plt.barh(m_ys, m_widths, left=m_lefts, label='tasks', color='orange')
if l_ys:
    plt.barh(l_ys, l_widths, left=l_lefts, label='Library Tasks', color='green')
plt.tick_params(axis='y', labelleft=False)
plt.xlabel('Time (s)')
plt.legend()
plt.savefig('{}.pdf'.format(sys.argv[2]))
plt.show()








  







        
